<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Zhili">
<meta name="description" content="Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. Morbi mollis tellus ac sapien. Vestibulum ullamcorper mauris at ligula. In hac habitasse platea dictumst. Vivamus in erat ut urna cursus vestibulum.
    ">
<meta name="keywords" content="博客, 技术, 生物信息，精准医疗, 遗传咨询, 高通量技术, 算法, 学习, 作品, 写作, C&#43;&#43;, Perl">
<meta name="referrer" content="always">
<title>[EMCpp]Item-38 Be Aware of Varying Thread Handle Destructor Behavior - sy123.ml</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="/logo/favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://sy123.ml/">sy123.ml</a></h1><h2><a href="https://sy123.ml/">winter is coming.</a></h2>
  </div>
  <nav><a href="/tags/">Tags</a><a href="/about/">About</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>[EMCpp]Item-38 Be Aware of Varying Thread Handle Destructor Behavior</h1>
  </div>
<div class="meta">
  <div>2018-10-09 19:42</div>
  <div>
    <span><a href="https://sy123.ml/tags/technique/">#technique</a></span>
      <span><a href="https://sy123.ml/tags/cpp/">#cpp</a></span>
      </div>
  </div>
<div class="content">
  <p>Future destructors normally just destroy the future's data members, execept for the final future referring to a shared state for a non-deferred task launched via <code>std::async</code>, which blocks until the task completes.</p>
<p>Item 37 notes that the destruction of a joinable <code>std::thread</code> terminates the program. As a comparicon, the behavior of destructor for a future is quit different.</p>
<p>To take a closer examination on future's destruction behavior, let's first understand that future is one end of a communications channel through which a callee transmits a result to a caller. The model works like this:</p>
<ol>
<li>The callee (usually running asynchronously) writes the result of its computation into the communications channel (typically via a <code>std::promise</code> object</li>
<li>A location known as <em>shared state</em> (typically represented by a heap-based object, which is outside both caller and callee) then stores a copy of the result, which is previously local to the callee and will be destroyed when the callee finished</li>
<li>As the name suggests, this location is also accessible by futures that are associated with the caller.</li>
</ol>
<p>The relationship looks like this:</p>
<pre><code>      future           Shared State             std::promise
Caller&lt;---------------Callee's Result&lt;----------------------Callee
                                                 (typically)

</code></pre><p>Now comes the behavior of a future's destructor:</p>
<ul>
<li>The destructor for the last future referring to a shared state for a non-deferred task launched via std::async blocks until the task completes (which acts like an implicit <code>join</code> on the underlying thread)</li>
<li>The destructor for all other futures simply destroys the future object (which acts like an implicit <code>detach</code> on the underlying thread.)</li>
</ul>
<p>In other words, the implicit <code>join</code> occurs only if all of the following apply to a future:</p>
<ul>
<li>it refers to a shared state that was created due to a call to <code>std::async</code></li>
<li>the task's launch policy is <code>std::launch::async</code>, either because that was chosen by the runtime system or because it was specified in the call to <code>std::async</code></li>
<li>the future is the last one referring to the shared state. For <code>std::future</code>s, this is always the case. For <code>std::shared_future</code>s, other earlier future's destructor simply destroys its data members</li>
</ul></div>

  </article>
</main>
<footer>
  <div>
    <div>
      2007-2020 Zhili.</div>
  </div>
</footer>
</body>
</html>
