<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Zhili">
<meta name="description" content="Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. Morbi mollis tellus ac sapien. Vestibulum ullamcorper mauris at ligula. In hac habitasse platea dictumst. Vivamus in erat ut urna cursus vestibulum.
    ">
<meta name="keywords" content="博客, 技术, 生物信息，精准医疗, 遗传咨询, 高通量技术, 算法, 学习, 作品, 写作, C&#43;&#43;, Perl">
<meta name="referrer" content="always">
<title>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39; - sy123.ml</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="/logo/favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://sy123.ml/">sy123.ml</a></h1><h2><a href="https://sy123.ml/">winter is coming.</a></h2>
  </div>
  <nav><a href="/tags/">Tags</a><a href="/about/">About</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39;</h1>
  </div>
<div class="meta">
  <div>2018-03-29 11:18</div>
  <div>
    <span><a href="https://sy123.ml/tags/technique/">#technique</a></span>
      <span><a href="https://sy123.ml/tags/cpp/">#cpp</a></span>
      </div>
  </div>
<div class="content">
  <p>If we don't have a good reason for overloading an operator, don't overload it. In the case of <code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>, it's difficult to have a good reason: we can't make them behave the way they're supposed to.</p>
<!-- toc -->
<h1 id="overloading-operator-and-operator">Overloading <code>operator&amp;&amp;</code> and <code>operator||</code></h1>
<p>C++ employs short-circuit evaluation of boolean expressions: once the truth or falsehood of an expression has been determined, evaluation of the expression ceases, even if somem parts of the expression haven't yet been examined.</p>
<p>The operators associated with short-circuit evaluation are <code>||</code> and <code>&amp;&amp;</code>, which C++ allows us to customize for user-defined types. However, once we overloading the functions <code>operator&amp;&amp;</code> and <code>operator||</code> (at the global scope or on a  per-class basis), we are replacing short-circuit semantics with <em>function call</em> semantics, ending up changing the rules of the game quite radically. For example, after we overload <code>operator&amp;&amp;</code>, the following code:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">expression1</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#111">expression2</span><span style="color:#111">)</span>  <span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span>
</code></pre></td></tr></table>
</div>
</div><p>looks to compilers like one of these:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">expression1</span><span style="color:#111">.</span><span style="color:#00a8c8">operator</span><span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span><span style="color:#111">(</span><span style="color:#111">expression2</span><span style="color:#111">)</span><span style="color:#111">)</span> <span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span> <span style="color:#75715e">// when operator&amp;&amp; is a member function
</span><span style="color:#75715e"></span>
<span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#00a8c8">operator</span><span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span><span style="color:#111">(</span><span style="color:#111">expression1</span><span style="color:#111">,</span> <span style="color:#111">expression2</span><span style="color:#111">)</span><span style="color:#111">)</span> <span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span> <span style="color:#75715e">// when operator&amp;&amp; is a global function
</span></code></pre></td></tr></table>
</div>
</div><p>In two crucial ways, the funciton call semantics differ from short-circuit semantics:</p>
<ol>
<li>when a funciton all is made, <em>all</em> parameters must be evaluated. Thus there is no short circuit.</li>
<li>the order of evaluation of parameters to a function all is undefined, so there is no way of knowing whether <code>expression1</code> or <code>expression2</code> will be evaluated first.</li>
</ol>
<p>As a result, overloaded <code>&amp;&amp;</code> or <code>||</code> will never offer programmers the behavior they both exprect and have come to depend on. So do not overload <code>&amp;&amp;</code> or <code>||</code>.</p>
<h1 id="overloading-operator">Overloading <code>operator,</code></h1>
<p>The comma operator is used for <em>expressions</em>, and we're most likely to run across it in the update part of a <code>for</code> loop:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">void</span> <span style="color:#75af00">reverse</span><span style="color:#111">(</span><span style="color:#00a8c8">char</span> <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#111">]</span><span style="color:#111">)</span> 
<span style="color:#111">{</span>
    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">,</span> <span style="color:#111">j</span> <span style="color:#f92672">=</span> <span style="color:#111">strlen</span><span style="color:#111">(</span><span style="color:#111">s</span><span style="color:#111">)</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#111">;</span>
    <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">j</span><span style="color:#111">;</span>
    <span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#111">i</span><span style="color:#111">,</span> <span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#111">j</span><span style="color:#111">)</span>  <span style="color:#75715e">// the comma operator
</span><span style="color:#75715e"></span>    <span style="color:#111">{</span>
        <span style="color:#00a8c8">int</span> <span style="color:#111">c</span> <span style="color:#f92672">=</span> <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span><span style="color:#111">;</span>
        <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">]</span><span style="color:#111">;</span>
        <span style="color:#111">s</span><span style="color:#111">[</span><span style="color:#111">j</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">c</span><span style="color:#111">;</span>
    <span style="color:#111">}</span>
<span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><p>An expression containing a comma is evaluated by first evaluating the part of the expression to the left of the comma, then evaluating the expression to the right of the comma; the result of the overall comma expression is the value of the expression on the right. So the result for <code>++i, --j</code> is the value returned from <code>--j</code>.</p>
<p>Unfortunately, when writing our own comma operator, we can't mimic this behavior for the same reason as the case in overriding <code>||</code> and <code>&amp;&amp;</code>:</p>
<ul>
<li>if we write <code>operator,</code> as a non-member function, then both operands around <code>,</code> will be passed as arguments in a function call, and there's no way to control over the order in which a funciton's arguments are evaluated.</li>
<li>if we write <code>operator,</code> as a member function, we still can't rely on the left-hand operand to the comma being evaluated first, because compilers are not constrained to do thing that way.</li>
</ul>
<h1 id="limits-on-operator-overloading">Limits on operator overloading</h1>
<p>According to C++, following operators can't be overloaded:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>.</code></td>
<td align="center"><code>.*</code></td>
<td align="center"><code>::</code></td>
<td align="center"><code>?:</code></td>
</tr>
<tr>
<td align="center"><code>new</code></td>
<td align="center"><code>delete</code></td>
<td align="center"><code>sizeof</code></td>
<td align="center"><code>typeid</code></td>
</tr>
<tr>
<td align="center"><code>static_cast</code></td>
<td align="center"><code>dynamic_cast</code></td>
<td align="center"><code>const_cast</code></td>
<td align="center"><code>reinterpret_cast</code></td>
</tr>
</tbody>
</table>
<p>We can overload these:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>operator new</code></td>
<td align="center"><code>operator delete</code></td>
<td align="center"><code>operator new[]</code></td>
<td align="center"><code>operator delete[]</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>-</code></td>
<td align="center"><code>*</code></td>
<td align="center"><code>/</code></td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center"><code>^</code></td>
<td align="center"><code>&amp;</code></td>
<td align="center">|</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center"><code>!</code></td>
<td align="center"><code>&lt;</code></td>
<td align="center"><code>&gt;</code></td>
</tr>
<tr>
<td align="center"><code>+=</code></td>
<td align="center"><code>-=</code></td>
<td align="center"><code>*=</code></td>
<td align="center"><code>/=</code></td>
</tr>
<tr>
<td align="center"><code>%=</code></td>
<td align="center"><code>^=</code></td>
<td align="center"><code>&amp;</code></td>
<td align="center"><code>|=</code></td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center"><code>&gt;&gt;=</code></td>
<td align="center"><code>&lt;&lt;=</code></td>
</tr>
<tr>
<td align="center"><code>==</code></td>
<td align="center"><code>!=</code></td>
<td align="center"><code>&lt;=</code></td>
<td align="center"><code>&gt;=</code></td>
</tr>
<tr>
<td align="center"><code>-&gt;*</code></td>
<td align="center"><code>-&gt;</code></td>
<td align="center"><code>++</code></td>
<td align="center"><code>--</code></td>
</tr>
<tr>
<td align="center"><code>,</code></td>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">||</td>
<td></td>
</tr>
<tr>
<td align="center"><code>()</code></td>
<td align="center"><code>[]</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Just because we can overload there operators is no reason to run off and do it. The purpose of operator overloading is to make programs easier to read, write, and understand. If we don't have a good reason for overloading an operator, don't overload it, as is the case for <code>&amp;&amp;</code>, <code>||</code>, and <code>,</code>.</p></div>

  </article>
</main>
<footer>
  <div>
    <div>
      2007-2020 Zhili.</div>
  </div>
</footer>
</body>
</html>
