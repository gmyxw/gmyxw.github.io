<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Zhili">
<meta name="description" content="Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. Morbi mollis tellus ac sapien. Vestibulum ullamcorper mauris at ligula. In hac habitasse platea dictumst. Vivamus in erat ut urna cursus vestibulum.
    ">
<meta name="keywords" content="博客, 技术, 生物信息，精准医疗, 遗传咨询, 高通量技术, 算法, 学习, 作品, 写作, C&#43;&#43;, Perl">
<meta name="referrer" content="always">
<title>[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle - sy123.ml</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="/logo/favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://sy123.ml/">sy123.ml</a></h1><h2><a href="https://sy123.ml/">winter is coming.</a></h2>
  </div>
  <nav><a href="/tags/">Tags</a><a href="/about/">About</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle</h1>
  </div>
<div class="meta">
  <div>2018-08-01 18:44</div>
  <div>
    <span><a href="https://sy123.ml/tags/technique/">#technique</a></span>
      <span><a href="https://sy123.ml/tags/cpp/">#cpp</a></span>
      </div>
  </div>
<div class="content">
  <p>Potential use cases for <code>std::weak_ptr</code> include caching, observer lists, and the prevention of <code>std::shared_ptr</code> cycles.</p>
<p>From an efficiency perspective, the <code>std::weak_ptr</code> is essentially the same as <code>std::shared_ptr</code>, except that they don't participate in the <em>shared ownership</em> of objects and hence don't affect the <em>pointed-to object's reference count</em>. However, they do manipulate a second reference count in the control block (<em>weak count</em>), so they actually do all the same operations such as construction, destruction, and assignment involve atomic reference count manipulations.</p>
<p>As a fact, <code>std::weak_ptr</code> isn't a standalone smart pointer, but an augmentation of <code>std::shared_ptr</code>:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">auto</span> <span style="color:#111">spw</span> <span style="color:#f92672">=</span> <span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">make_shared</span><span style="color:#f92672">&lt;</span><span style="color:#111">Widget</span><span style="color:#f92672">&gt;</span><span style="color:#111">(</span><span style="color:#111">)</span><span style="color:#111">;</span> <span style="color:#75715e">// reference count (RC) is 1 after spw is constructed
</span><span style="color:#75715e"></span><span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span>
<span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">weak_ptr</span><span style="color:#f92672">&lt;</span><span style="color:#111">Widget</span><span style="color:#f92672">&gt;</span> <span style="color:#111">wpw</span><span style="color:#111">(</span><span style="color:#111">spw</span><span style="color:#111">)</span><span style="color:#111">;</span>   <span style="color:#75715e">// RC remains 1 
</span><span style="color:#75715e"></span><span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span>
<span style="color:#111">spw</span> <span style="color:#f92672">=</span> <span style="color:#00a8c8">nullptr</span><span style="color:#111">;</span> <span style="color:#75715e">// RC becomes 0, Widget gets destroyed, wpw dangles
</span><span style="color:#75715e"></span><span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">wpw</span><span style="color:#111">.</span><span style="color:#111">exipred</span><span style="color:#111">(</span><span style="color:#111">)</span><span style="color:#111">)</span> <span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span>  <span style="color:#75715e">// true
</span></code></pre></td></tr></table>
</div>
</div><p>Usually, the purpose of creating a <code>std::weak_ptr</code> is to check the dangling <code>std::weak_ptr</code> (when the related control block has zero-value reference count), and if it hasn't expired, we may access the object it points to. Separating the check and the dereference would introduce a race condition, so we need an atomic operation to check and access the object at the same time. There are two ways to do this:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">auto</span> <span style="color:#111">spw1</span> <span style="color:#f92672">=</span> <span style="color:#111">wpw</span><span style="color:#111">.</span><span style="color:#111">lock</span><span style="color:#111">(</span><span style="color:#111">)</span><span style="color:#111">;</span>  <span style="color:#75715e">// spw1 type is shared_ptr&lt;Widget&gt;; if wpw&#39;s expired, spw1 is null
</span><span style="color:#75715e"></span><span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">shared_ptr</span><span style="color:#f92672">&lt;</span><span style="color:#111">Widget</span><span style="color:#f92672">&gt;</span> <span style="color:#111">spw2</span><span style="color:#111">(</span><span style="color:#111">wpw</span><span style="color:#111">)</span><span style="color:#111">;</span>  <span style="color:#75715e">// if wpw&#39;s expired, throw std::bad_weak_ptr
</span></code></pre></td></tr></table>
</div>
</div><p>There are at least three use cases for <code>std::weak_ptr</code>.</p>
<h4 id="caching">Caching</h4>
<p>Given a factory function returning <code>std::unique_ptr</code>:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">unique_ptr</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">const</span> <span style="color:#111">Widget</span><span style="color:#f92672">&gt;</span> <span style="color:#111">loadWidget</span><span style="color:#111">(</span><span style="color:#111">WidgetID</span> <span style="color:#111">id</span><span style="color:#111">)</span><span style="color:#111">;</span>
</code></pre></td></tr></table>
</div>
</div><p>We might consider wrap a cache layer on top of <code>loadWidget</code> due to considerations such as expensive database I/O cost or frequent queries from clients. A quick-and-dirty implementation using <code>std::weak_ptr</code> may fit the requirement<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">shared_ptr</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">const</span> <span style="color:#111">Widget</span><span style="color:#f92672">&gt;</span> <span style="color:#111">fastLoadWidget</span><span style="color:#111">(</span><span style="color:#111">WidgetID</span> <span style="color:#111">id</span><span style="color:#111">)</span>
<span style="color:#111">{</span>
    <span style="color:#00a8c8">static</span> <span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">unordered_map</span><span style="color:#f92672">&lt;</span><span style="color:#111">WidgetID</span><span style="color:#111">,</span> 
                              <span style="color:#111">std</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#111">weak_ptr</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">const</span> <span style="color:#111">Widget</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> <span style="color:#111">cache</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">auto</span> <span style="color:#111">objPtr</span> <span style="color:#f92672">=</span> <span style="color:#111">cache</span><span style="color:#111">[</span><span style="color:#111">id</span><span style="color:#111">]</span><span style="color:#111">.</span><span style="color:#111">lock</span><span style="color:#111">(</span><span style="color:#111">)</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#f92672">!</span><span style="color:#111">objPtr</span><span style="color:#111">)</span> <span style="color:#111">{</span>
        <span style="color:#111">objPtr</span> <span style="color:#f92672">=</span> <span style="color:#111">loadWidget</span><span style="color:#111">(</span><span style="color:#111">id</span><span style="color:#111">)</span><span style="color:#111">;</span>
        <span style="color:#111">cache</span><span style="color:#111">[</span><span style="color:#111">id</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">objPtr</span><span style="color:#111">;</span>
    <span style="color:#111">}</span>
    <span style="color:#00a8c8">return</span> <span style="color:#111">objPtr</span><span style="color:#111">;</span>
<span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="observer-list">Observer list</h4>
<p>In the Observer design pattern, there are two components:</p>
<ol>
<li>subjects: whose state may change</li>
<li>observers: who will be notified when state changes occur</li>
</ol>
<p>Each subject may contain a data member holding pointers to its observers to issue state change notifications. Since subjects only cares if an observer gets destroyed (to cancel subsequent notifications) and needn't control the lifetime of their observers, a reasonable design, therefore, is to let each subject hold a container of <code>std::weak_ptr</code>s to its observers, and check if a pointer dangles before using it.</p>
<h4 id="cycling-prevention">Cycling prevention</h4>
<p>In strictly hierarchal data structures such as trees, child nodes are typially owned only by their parents. When a parent node is destroyed, child nodes are destroyed, too. Links from parents to children are generally best represented by <code>std::unique_ptr</code>, while back-links from children to parents can be safely implemented as raw pointers<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>In other pointer-based non-strict-hierarchical data structure, however, forward-links may be best implemented in terms of <code>std::shared_ptr</code>, and to prevent cycles, which will lead to resource leak<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, back-link should use <code>std::weak_ptr</code>.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>A potential refinement is to remove the expired cache, since right now the cache accumulate <code>std::weak_ptr</code> corresponding to <code>Widget</code>s that are no longer in use (and have therefore been destroyed). <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Children have a shorter lifetime than their parent node, so there's no risk of a child node dereferencing a dangling parent pointer. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Two <code>std::shared_ptr</code>s point to each other wil prevent both from being destroyed: even if both object are unreachable from other program data structures, each will have a reference count of one. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section></div>

  </article>
</main>
<footer>
  <div>
    <div>
      2007-2020 Zhili.</div>
  </div>
</footer>
</body>
</html>
