<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Zhili">
<meta name="description" content="Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. Morbi mollis tellus ac sapien. Vestibulum ullamcorper mauris at ligula. In hac habitasse platea dictumst. Vivamus in erat ut urna cursus vestibulum.
    ">
<meta name="keywords" content="博客, 技术, 生物信息，精准医疗, 遗传咨询, 高通量技术, 算法, 学习, 作品, 写作, C&#43;&#43;, Perl">
<meta name="referrer" content="always">
<title>Item-21 Don&#39;t return a reference when we have to return an object - sy123.ml</title>
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="icon" href="/logo/favicon.ico" type="image/x-icon">
</head>
<body>
<header>
  <div>
    <h1><a href="https://sy123.ml/">sy123.ml</a></h1><h2><a href="https://sy123.ml/">winter is coming.</a></h2>
  </div>
  <nav><a href="/tags/">Tags</a><a href="/about/">About</a></nav>
</header>
<main>
  <article>
    <div class="title">
  <h1>Item-21 Don&#39;t return a reference when we have to return an object</h1>
  </div>
<div class="meta">
  <div>2018-02-09 18:02</div>
  <div>
    <span><a href="https://sy123.ml/tags/technique/">#technique</a></span>
      <span><a href="https://sy123.ml/tags/cpp/">#cpp</a></span>
      </div>
  </div>
<div class="content">
  <p>Never return a pointer or reference to a local stack object, a refenrence to a heap-allocated object, or a pointer or reference to a local static object if there is a change that more than one such object will be needed (item 4 provides a &ldquo;counter&rdquo; example that is reasonable in single-threaded environments).</p>
<!-- toc -->
<h1 id="case-study">Case Study</h1>
<p>There are some situations where we <strong>must</strong> return an object, no matter how much effort we want to put into rooting out the evil of pass-by-value to pursue the heighest efficiency. Otherwise, we may invariably make a fatal mistake: pass references to objects that don't exist.</p>
<p>Consider following class for representing rational numbers with a multiplying function:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">class</span> <span style="color:#75af00">Rational</span> <span style="color:#111">{</span>
<span style="color:#00a8c8">public</span><span style="color:#f92672">:</span>
    <span style="color:#111">Rational</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">numerator</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">,</span>     <span style="color:#75715e">// see item 24 for why this
</span><span style="color:#75715e"></span>            <span style="color:#00a8c8">int</span> <span style="color:#111">denominator</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#111">)</span><span style="color:#111">;</span>   <span style="color:#75715e">// ctor isn&#39;t declared explicit
</span><span style="color:#75715e"></span><span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span>
<span style="color:#00a8c8">private</span><span style="color:#f92672">:</span>
    <span style="color:#00a8c8">int</span> <span style="color:#111">n</span><span style="color:#111">,</span><span style="color:#111">d</span><span style="color:#111">;</span> <span style="color:#75715e">// numerator and denominator
</span><span style="color:#75715e"></span><span style="color:#00a8c8">friend</span><span style="color:#f92672">:</span>
    <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span>  <span style="color:#75715e">// see item 3 for why the return type is const
</span><span style="color:#75715e"></span>    <span style="color:#00a8c8">operator</span><span style="color:#f92672">*</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">lhs</span><span style="color:#111">,</span>
               <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">rhs</span><span style="color:#111">)</span><span style="color:#111">;</span>
<span style="color:#111">}</span><span style="color:#111">;</span>
</code></pre></td></tr></table>
</div>
</div><p>We may want to remove the cost of construction and destruction from return-by-value, considering using return by reference instead. However, a reference is just a name for some <em>existing</em> object. In the case of <code>opeartor*</code>, the product of the two object does not exist before we call the function, so if <code>operator*</code> want to return a reference to the product, it must create the result itself.</p>
<p>A function can create a new object in only two ways: on the stack or on the heap.</p>
<h1 id="return-a-pointer-or-reference-to-a-local-stack-object">Return a pointer or reference to a local stack object</h1>
<p>Creation on the stack is accomplished by defining a local variable:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#00a8c8">operator</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">lhs</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">rhs</span><span style="color:#111">)</span> <span style="color:#75715e">// bad code !
</span><span style="color:#75715e"></span><span style="color:#111">{</span>
    <span style="color:#111">Rational</span> <span style="color:#75af00">result</span><span style="color:#111">(</span><span style="color:#111">lhs</span><span style="color:#111">.</span><span style="color:#111">n</span> <span style="color:#f92672">*</span> <span style="color:#111">rhs</span><span style="color:#111">.</span><span style="color:#111">n</span><span style="color:#111">,</span> <span style="color:#111">lhs</span><span style="color:#111">.</span><span style="color:#111">d</span> <span style="color:#f92672">*</span> <span style="color:#111">rhs</span><span style="color:#111">.</span><span style="color:#111">d</span><span style="color:#111">)</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">return</span> <span style="color:#111">result</span><span style="color:#111">;</span>
<span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><p>There's a serious problem: the function returns a reference to <code>result</code>, which is a local object, and local objects are destroyed when the function exits, ending to return a reference to an ex-<code>Rational</code>. Any caller glancing at this return value would instantly enter the realm of undefined behavior.</p>
<p>The fact is, any function returning a reference (or a pointer) to a local object is brocken.</p>
<h1 id="return-a-reference-to-a-heap-allocated-object">Return a reference to a heap-allocated object</h1>
<p>Heap-based objects come into being through the use of <code>new</code>, so the heap-based <code>opearator*</code> looks like this:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">operation</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">lhs</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">rhs</span><span style="color:#111">)</span> <span style="color:#75715e">// bad code !
</span><span style="color:#75715e"></span><span style="color:#111">{</span>
    <span style="color:#111">Rational</span> <span style="color:#f92672">*</span><span style="color:#111">result</span> <span style="color:#f92672">=</span> <span style="color:#00a8c8">new</span> <span style="color:#111">Raional</span><span style="color:#111">(</span><span style="color:#111">lhs</span><span style="color:#111">.</span><span style="color:#111">n</span> <span style="color:#f92672">*</span> <span style="color:#111">rhs</span><span style="color:#111">.</span><span style="color:#111">n</span><span style="color:#111">,</span> <span style="color:#111">lhs</span><span style="color:#111">.</span><span style="color:#111">d</span> <span style="color:#f92672">*</span> <span style="color:#111">rhs</span><span style="color:#111">.</span><span style="color:#111">d</span><span style="color:#111">)</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">return</span> <span style="color:#f92672">*</span><span style="color:#111">result</span><span style="color:#111">;</span>
<span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now comes a different problem: who will apply <code>delete</code> matching the use of <code>new</code>?</p>
<p>Even if callers are conscientious and well intentioned, there's not much they can do to prevent leaks in reasonable usage scenarios like this:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#111">Rational</span> <span style="color:#111">x</span><span style="color:#111">,</span> <span style="color:#111">y</span><span style="color:#111">,</span> <span style="color:#111">z</span><span style="color:#111">;</span>

<span style="color:#111">Rational</span> <span style="color:#111">w</span> <span style="color:#f92672">=</span> <span style="color:#111">x</span> <span style="color:#f92672">*</span> <span style="color:#111">y</span> <span style="color:#f92672">*</span> <span style="color:#111">z</span><span style="color:#111">;</span> <span style="color:#75715e">// same as operator*(operator*(x,y),z)
</span></code></pre></td></tr></table>
</div>
</div><p>There are twoe uses of <code>new</code> that need to be undone with uses of <code>delete</code>. Yet there's no reasonable way for clients to get at the pointers hidden behind the references being returned from the calls to <code>operator*</code> and make calls to <code>delete</code>. This is a guaranteed resource leak.</p>
<h1 id="return-a-reference-to-a-local-static-object">Return a reference to a local static object</h1>
<p>If, however, we jump outside of the box, considering returning a reference to a <em>static</em> <code>Rational</code>, and think that this will avoid all but one initial constructor call without suffering from calling a constructor for each product result returned from <code>operatior*</code> in above on-the-stack and on-the-heap approaches:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#00a8c8">operator</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">lhs</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">rhs</span><span style="color:#111">)</span> <span style="color:#75715e">// bad code !
</span><span style="color:#75715e"></span><span style="color:#111">{</span>
    <span style="color:#00a8c8">static</span> <span style="color:#111">Rational</span> <span style="color:#111">result</span><span style="color:#111">;</span>  <span style="color:#75715e">// static object
</span><span style="color:#75715e"></span>    <span style="color:#111">result</span> <span style="color:#f92672">=</span> <span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">;</span> <span style="color:#75715e">// put the product inside result
</span><span style="color:#75715e"></span>    <span style="color:#00a8c8">return</span> <span style="color:#111">result</span><span style="color:#111">;</span>
<span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Like all designs employing the use of static objects, this one immediately raises thread-safety hackles, but there's a deeper flaw: consider following perfectly reasonable client code:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">bool</span> <span style="color:#00a8c8">operator</span><span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">lhs</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">rhs</span><span style="color:#111">)</span><span style="color:#111">;</span> 
<span style="color:#111">Rational</span> <span style="color:#111">a</span><span style="color:#111">,</span><span style="color:#111">b</span><span style="color:#111">,</span><span style="color:#111">c</span><span style="color:#111">,</span><span style="color:#111">d</span><span style="color:#111">;</span>
<span style="color:#111">.</span><span style="color:#111">.</span><span style="color:#111">.</span>
<span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">(</span><span style="color:#111">a</span> <span style="color:#f92672">*</span> <span style="color:#111">b</span><span style="color:#111">)</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#111">(</span><span style="color:#111">c</span> <span style="color:#f92672">*</span> <span style="color:#111">d</span><span style="color:#111">)</span><span style="color:#111">)</span> <span style="color:#111">{</span>
    <span style="color:#75715e">// do whatever appropriate when the products are equal
</span><span style="color:#75715e"></span><span style="color:#111">}</span> <span style="color:#00a8c8">else</span> <span style="color:#111">{</span>
    <span style="color:#75715e">// do whatever appropriate when the products are unequal
</span><span style="color:#75715e"></span><span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Problem here is that the expression <code>((a * b) == (c * d))</code> will <em>always</em> evaluate to <code>true</code>, regardless of the values of a, b, c, and d.</p>
<p>Let's rewrite the code in its equivalent functional form to understand what happened:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#00a8c8">operator</span><span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#111">(</span><span style="color:#00a8c8">operator</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#111">a</span><span style="color:#111">,</span> <span style="color:#111">b</span><span style="color:#111">)</span><span style="color:#111">,</span> <span style="color:#00a8c8">operator</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#111">c</span><span style="color:#111">,</span> <span style="color:#111">d</span><span style="color:#111">)</span><span style="color:#111">)</span><span style="color:#111">)</span>
</code></pre></td></tr></table>
</div>
</div><p>When <code>operator==</code> is called, there will already be two active calls to <code>opearator*</code>, each of which will return a reference to the static <code>Rational</code> object inside <code>opeartion*</code>, which, as is a static local object, will always be the exact one, with same value.</p>
<p>Some may ask,</p>
<blockquote>
<p>Well, if <em>one</em> static isn't enough, maybe a static <em>array</em> will do the trick&hellip;</p>
</blockquote>
<p>The problem is, however, it is very hard to implement this arry of size <code>n</code>:</p>
<ul>
<li>if <code>n</code> is too small, we may run out of places to store return values and fall back to the single-static design situation;</li>
<li>if <code>n</code> is too big, we'll decrease the performance of the program, because every object in the array will be constructed the first time the function is called - a cost of <code>n</code> constructors and equally <code>n</code> destructors even if the function is called only once.</li>
<li>how to put the values we need into the array's objects and what is the cost. The most direct way is via assignment, which cost the same as a call to a destructor (to destroy the old value) plus a call to a constructor (to copy over the new value)</li>
<li>how to decide the position of target result in the array</li>
</ul>
<h1 id="the-right-way-return-by-value">The right way: return by value</h1>
<p>The right way to write a function that must return a new object is to have that function reutrn a new object like this or something essentially equivalent:</p>
<div class="highlight"><div style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a8c8">inline</span> <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span> <span style="color:#00a8c8">operator</span><span style="color:#f92672">*</span><span style="color:#111">(</span><span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">lhs</span><span style="color:#111">,</span> <span style="color:#00a8c8">const</span> <span style="color:#111">Rational</span><span style="color:#f92672">&amp;</span> <span style="color:#111">rhs</span><span style="color:#111">)</span>
<span style="color:#111">{</span>
    <span style="color:#00a8c8">return</span> <span style="color:#75af00">Rational</span><span style="color:#111">(</span><span style="color:#111">lhs</span><span style="color:#111">.</span><span style="color:#111">n</span> <span style="color:#f92672">*</span> <span style="color:#111">rhs</span><span style="color:#111">.</span><span style="color:#111">n</span><span style="color:#111">,</span> <span style="color:#111">lhs</span><span style="color:#111">.</span><span style="color:#111">d</span> <span style="color:#f92672">*</span> <span style="color:#111">rhs</span><span style="color:#111">.</span><span style="color:#111">d</span><span style="color:#111">)</span><span style="color:#111">;</span>
<span style="color:#111">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the long run, the cost of constructing and destructing <code>operator*</code>'s return value is a small price to pay for correct behavior. What's more, since C++ allows compiler implementers to apply optimizations to immprove the performance of the generated code, it turns out that in some cases, construction and destruction of <code>operator*</code>'s return value can be safely eliminated, so the program will run faster than we expect and still behave correctly as it's supposed to be.</p>
<p>In summary, when deciding between returning a reference and returning an object, we should make choice that offers correct behavior.</p></div>

  </article>
</main>
<footer>
  <div>
    <div>
      2007-2020 Zhili.</div>
  </div>
</footer>
</body>
</html>
