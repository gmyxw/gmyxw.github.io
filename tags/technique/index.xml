<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>technique on sy123.ml</title>
    <link>https://sy123.ml/tags/technique/</link>
    <description>Recent content in technique on sy123.ml</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>2007-2020 Zhili.</copyright>
    <lastBuildDate>Sun, 16 Dec 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://sy123.ml/tags/technique/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Trade Beats</title>
      <link>https://sy123.ml/2018/12/16/use-trading-market-data-to-create-beat-sounds/</link>
      <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/12/16/use-trading-market-data-to-create-beat-sounds/</guid>
      <description>&lt;p&gt;What would it sound like if trading market data speaks?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-40 Use std::atomic for Concurrency, volatile for Special Memory</title>
      <link>https://sy123.ml/2018/10/30/use-stdatomic-for-concurrency-volatile-for-special-memory/</link>
      <pubDate>Tue, 30 Oct 2018 19:05:01 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/10/30/use-stdatomic-for-concurrency-volatile-for-special-memory/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::atomic&lt;/code&gt; is for data accessed from multiple threads without using mutexes (concurrent usage); &lt;code&gt;volatile&lt;/code&gt; is for memory where reads and writes should not be optimised away (special memory).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-38 Be Aware of Varying Thread Handle Destructor Behavior</title>
      <link>https://sy123.ml/2018/10/09/be-aware-of-varying-thread-handle-destructor-behavior/</link>
      <pubDate>Tue, 09 Oct 2018 19:42:16 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/10/09/be-aware-of-varying-thread-handle-destructor-behavior/</guid>
      <description>&lt;p&gt;Future destructors normally just destroy the future&#39;s data members, execept for the final future referring to a shared state for a non-deferred task launched via &lt;code&gt;std::async&lt;/code&gt;, which blocks until the task completes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-36 Specify std::launch::async if Asynchronicity Is Essential</title>
      <link>https://sy123.ml/2018/10/01/specify-stdlaunchasync-if-asynchronicity-is-essential/</link>
      <pubDate>Mon, 01 Oct 2018 18:33:54 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/10/01/specify-stdlaunchasync-if-asynchronicity-is-essential/</guid>
      <description>&lt;p&gt;The flexibility that default policy for &lt;code&gt;std::async&lt;/code&gt; permits both async and sync task execution leads to uncertainty when accessing &lt;code&gt;thread_locals&lt;/code&gt;, implies that the task may never execute, and affects program logic for timeout-based &lt;code&gt;wait&lt;/code&gt; calls.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-35 Prefer Task-Based Programming to Thread-Based</title>
      <link>https://sy123.ml/2018/08/28/prefer-task-based-programming-to-thread-based/</link>
      <pubDate>Tue, 28 Aug 2018 10:19:06 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/28/prefer-task-based-programming-to-thread-based/</guid>
      <description>&lt;p&gt;Thread-based programming calls for manual management of thread exhaustion, oversubscription, load balancing, and adaptation to new platforms, while task-based programming via &lt;code&gt;std::async&lt;/code&gt; with the default launch policy handles most of the issues for us.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-34 Prefer Lambdas to std::bind</title>
      <link>https://sy123.ml/2018/08/24/prefer-lambdas-to-stdbind/</link>
      <pubDate>Fri, 24 Aug 2018 20:07:38 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/24/prefer-lambdas-to-stdbind/</guid>
      <description>&lt;p&gt;Lambdas are more readable, more expressive, and may be more efficient than using &lt;code&gt;std::bind&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-33 Use decltype on auto&amp;&amp; parameters to std::forward them</title>
      <link>https://sy123.ml/2018/08/23/use-decltype-on-auto-parameters-to-stdforward-them/</link>
      <pubDate>Thu, 23 Aug 2018 21:44:29 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/23/use-decltype-on-auto-parameters-to-stdforward-them/</guid>
      <description>&lt;p&gt;C++14 introduces generic lambdas, which use &lt;code&gt;auto&lt;/code&gt; in their parameter specifications.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-32 Use Init Capture to Move Objects Into Closures</title>
      <link>https://sy123.ml/2018/08/22/use-init-capture-to-move-objects-into-closures/</link>
      <pubDate>Wed, 22 Aug 2018 18:24:02 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/22/use-init-capture-to-move-objects-into-closures/</guid>
      <description>&lt;p&gt;Use init capture to move objects into closures in C++14; emulate init capture via hand-written classes or &lt;code&gt;std::bind&lt;/code&gt; in C++11.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-31 Avoid Default Capture Modes</title>
      <link>https://sy123.ml/2018/08/21/avoid-default-capture-modes/</link>
      <pubDate>Tue, 21 Aug 2018 19:22:22 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/21/avoid-default-capture-modes/</guid>
      <description>&lt;p&gt;Default by-reference capture can lead to dangling references; default by-value capture is susceptible to dangling pointers, while misleadingly susggests the lambdas are self-contained.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-30 Failure Cases in Perfect Forwarding</title>
      <link>https://sy123.ml/2018/08/19/failure-cases-in-perfect-forwarding/</link>
      <pubDate>Sun, 19 Aug 2018 16:10:34 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/19/failure-cases-in-perfect-forwarding/</guid>
      <description>&lt;p&gt;Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-29 Assume Move Operations Are Not Present Not Cheap, and Not Used</title>
      <link>https://sy123.ml/2018/08/18/assume-move-operations-are-not-present-not-cheap-not-used/</link>
      <pubDate>Sat, 18 Aug 2018 15:15:12 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/18/assume-move-operations-are-not-present-not-cheap-not-used/</guid>
      <description>&lt;p&gt;There are several scenarios in which C++11&#39;s move semantics do us no good:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-28 Understand Reference Collapsing</title>
      <link>https://sy123.ml/2018/08/17/understand-reference-collapsing/</link>
      <pubDate>Fri, 17 Aug 2018 19:46:25 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/17/understand-reference-collapsing/</guid>
      <description>&lt;p&gt;Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-27 Alternatives to Overloading on Universal References</title>
      <link>https://sy123.ml/2018/08/15/alternatives-to-overloading-on-universal-references/</link>
      <pubDate>Wed, 15 Aug 2018 18:25:27 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/15/alternatives-to-overloading-on-universal-references/</guid>
      <description>&lt;p&gt;Universal reference parameters often have efficiency advantages, but they typically have usability disadvantages.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-26 Avoid Overloading on Universal References</title>
      <link>https://sy123.ml/2018/08/13/avoid-overloading-on-universal-references/</link>
      <pubDate>Mon, 13 Aug 2018 18:54:05 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/13/avoid-overloading-on-universal-references/</guid>
      <description>&lt;p&gt;Overloading on universal references almost always leads to the universal reference overload being called more frequently than expected.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-25 Use std::move on Rvalue References, std::forward on Universal References</title>
      <link>https://sy123.ml/2018/08/11/use-stdmove-on-rvalue-references-stdforward-on-universal-references/</link>
      <pubDate>Sat, 11 Aug 2018 15:26:53 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/11/use-stdmove-on-rvalue-references-stdforward-on-universal-references/</guid>
      <description>&lt;p&gt;But don&#39;t apply &lt;code&gt;std::move&lt;/code&gt; or &lt;code&gt;std::forward&lt;/code&gt; to local objects if they would otherwise be eligible for the return value optimization.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-24 Distinguish Universal References From Rvalue References</title>
      <link>https://sy123.ml/2018/08/08/distinguish-universal-references-from-rvalue-references/</link>
      <pubDate>Wed, 08 Aug 2018 18:56:09 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/08/distinguish-universal-references-from-rvalue-references/</guid>
      <description>&lt;p&gt;If a function template parameter has type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; for a deduced type &lt;code&gt;T&lt;/code&gt;, or if an object is declared using &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;, the parameter or object is a &lt;em&gt;universal reference&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-23 Understand std::Move and std::Forward</title>
      <link>https://sy123.ml/2018/08/07/understand-stdmove-and-stdforward/</link>
      <pubDate>Tue, 07 Aug 2018 17:57:26 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/07/understand-stdmove-and-stdforward/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt; performs an unconditional cast to an rvalue, while &lt;code&gt;std::forward&lt;/code&gt; casts its argument to an rvalue only if that argument is bound to an rvalue.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-22 When Using Pimple Idiom, Define Special Member Functions in the Implementation File</title>
      <link>https://sy123.ml/2018/08/05/prefer-make_unique-and-make_shared-to-direct-use-of-new/</link>
      <pubDate>Sun, 05 Aug 2018 23:46:08 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/05/prefer-make_unique-and-make_shared-to-direct-use-of-new/</guid>
      <description>&lt;p&gt;For &lt;code&gt;std::unique_ptr&lt;/code&gt; pImpl pointers, declare special member functions in the class header, but implement them in the implementation file.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-21 Prefer std::make_unique and std::make_shared to Direct Use of New</title>
      <link>https://sy123.ml/2018/08/02/prefer-make_unique-and-make_shared-to-direct-use-of-new/</link>
      <pubDate>Thu, 02 Aug 2018 18:45:53 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/02/prefer-make_unique-and-make_shared-to-direct-use-of-new/</guid>
      <description>&lt;p&gt;Compared to &lt;code&gt;new&lt;/code&gt;, make functions eliminate source code duplication, improve exception safety, and, for &lt;code&gt;std::make_shard&lt;/code&gt; and &lt;code&gt;std::allocate_shared&lt;/code&gt;, generate code that&#39;s smaller and faster.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle</title>
      <link>https://sy123.ml/2018/08/01/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/</link>
      <pubDate>Wed, 01 Aug 2018 18:44:19 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/08/01/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/</guid>
      <description>&lt;p&gt;Potential use cases for &lt;code&gt;std::weak_ptr&lt;/code&gt; include caching, observer lists, and the prevention of &lt;code&gt;std::shared_ptr&lt;/code&gt; cycles.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-19 Use std::Shared_ptr for Shared-ownership Resource Management</title>
      <link>https://sy123.ml/2018/07/31/use-shared_ptr-for-shared-ownership-resource-management/</link>
      <pubDate>Tue, 31 Jul 2018 17:59:25 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/31/use-shared_ptr-for-shared-ownership-resource-management/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::shared_ptrs&lt;/code&gt; offer convenience approaching that of garbage collection for the shared lifetime management of arbitrary resources.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-18 Use std::unique_ptr for Exclusive-ownership Resource Management</title>
      <link>https://sy123.ml/2018/07/30/use-unique_ptr-for-exclusive-ownership-resource-management/</link>
      <pubDate>Mon, 30 Jul 2018 15:18:04 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/30/use-unique_ptr-for-exclusive-ownership-resource-management/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-17 Understand Special Member Function Generation</title>
      <link>https://sy123.ml/2018/07/25/understand-special-member-function-generation/</link>
      <pubDate>Wed, 25 Jul 2018 20:26:53 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/25/understand-special-member-function-generation/</guid>
      <description>&lt;p&gt;The special member functions are those ccompilers may generate on their own: default constructor, destructor, copy operations, and move operations.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-16 Make Const Member Functions Thread Safe</title>
      <link>https://sy123.ml/2018/07/24/make-const-member-functions-thread-safe/</link>
      <pubDate>Tue, 24 Jul 2018 10:26:02 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/24/make-const-member-functions-thread-safe/</guid>
      <description>&lt;p&gt;Make &lt;code&gt;const&lt;/code&gt; member functions thread safe unless we&#39;re &lt;em&gt;certain&lt;/em&gt; they&#39;ll never be used in a concurrent context.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-15 Use Constexpr Whenever Possible</title>
      <link>https://sy123.ml/2018/07/23/use-constexpr-whenever-possible/</link>
      <pubDate>Mon, 23 Jul 2018 19:27:53 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/23/use-constexpr-whenever-possible/</guid>
      <description>&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; objects are &lt;code&gt;const&lt;/code&gt; and are initialized with values known during compilation; &lt;code&gt;constexpr&lt;/code&gt; functions can produce copmile-time results when called with arguments whose values are know during compilations.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-14 Declare Functions Noexcept if They Won&#39;t Emit Exception</title>
      <link>https://sy123.ml/2018/07/20/declare-functions-noexcept-if-they-wont-emit-exception/</link>
      <pubDate>Fri, 20 Jul 2018 19:50:39 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/20/declare-functions-noexcept-if-they-wont-emit-exception/</guid>
      <description>&lt;p&gt;Most functions are exception-neutral, but for some, such as move operations, swap, memory deallocation functions, and destructors, &lt;code&gt;noexcept&lt;/code&gt; is particularly valuable.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-13 Prefer Const_iterators to Iterators</title>
      <link>https://sy123.ml/2018/07/19/prefer-const_iterators-to-iterators/</link>
      <pubDate>Thu, 19 Jul 2018 18:48:52 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/19/prefer-const_iterators-to-iterators/</guid>
      <description>&lt;p&gt;In maximally generic code, prefer non-member versions of &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;rbegin&lt;/code&gt;, etc., over their member function counterparts.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-12 Declare Overriding Functions Override</title>
      <link>https://sy123.ml/2018/07/18/declare-overriding-functions-override/</link>
      <pubDate>Wed, 18 Jul 2018 19:19:07 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/18/declare-overriding-functions-override/</guid>
      <description>&lt;p&gt;C++11 gives us a way to make explicit that a derived class function is supposed to override a base class version: &lt;code&gt;override&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nodes on Clean Architecture</title>
      <link>https://sy123.ml/2018/07/17/nodes-on-clean-architecture/</link>
      <pubDate>Tue, 17 Jul 2018 19:45:47 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/17/nodes-on-clean-architecture/</guid>
      <description>&lt;p&gt;A brief notes on Clean Architecture&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-11 Prefer Deleted Functions to Private Undefined Ones</title>
      <link>https://sy123.ml/2018/07/16/prefer-deleted-functions-to-private-undefined-ones/</link>
      <pubDate>Mon, 16 Jul 2018 21:22:57 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/16/prefer-deleted-functions-to-private-undefined-ones/</guid>
      <description>&lt;p&gt;Any function may be deleted, including non-member functions and template instantiations.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-10 Prefer Scoped enums to Unscopded enums</title>
      <link>https://sy123.ml/2018/07/14/prefer-scoped-enums-to-unscopded-enums/</link>
      <pubDate>Sat, 14 Jul 2018 13:33:33 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/14/prefer-scoped-enums-to-unscopded-enums/</guid>
      <description>&lt;p&gt;Enumerators of scoped &lt;code&gt;enum&lt;/code&gt;s are visible only within the &lt;code&gt;enum&lt;/code&gt;, convert to other types only with a cast, and always support forward-declared because their default underlying type is &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-9 Prefer Alias Declarations to Typedefs</title>
      <link>https://sy123.ml/2018/07/12/prefer-alias-declarations-to-typedefs/</link>
      <pubDate>Thu, 12 Jul 2018 13:03:01 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/12/prefer-alias-declarations-to-typedefs/</guid>
      <description>&lt;p&gt;Alias declaration support templatization, which avoids the &amp;ldquo;::type&amp;rdquo; suffix and &amp;ldquo;typename&amp;rdquo; prefix often required to refer &lt;code&gt;typedef&lt;/code&gt;s.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-8 Prefer Nullptr to 0 and NULL</title>
      <link>https://sy123.ml/2018/07/11/prefer-nullptr-to-0-and-null/</link>
      <pubDate>Wed, 11 Jul 2018 18:03:51 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/11/prefer-nullptr-to-0-and-null/</guid>
      <description>&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt; doean&#39;t suffer from the overloading problem or the template deduction problem that 0 and &lt;code&gt;NULL&lt;/code&gt; are susceptible to. It also improves code clarity.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-7 Distinguish Betwenn () and {} When Creating Objects</title>
      <link>https://sy123.ml/2018/07/10/distinguish-betwenn-and-when-creating-objects/</link>
      <pubDate>Tue, 10 Jul 2018 18:55:06 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/10/distinguish-betwenn-and-when-creating-objects/</guid>
      <description>&lt;p&gt;Braced initialization is the most widely usable initialization syntax, which can also prevent narrowing conversions, as well as being immune to C++&#39;s most vexing parse.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-6 Use the Explicitly Typed Initializer Idiom when auto deduces undesired types</title>
      <link>https://sy123.ml/2018/07/08/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</link>
      <pubDate>Sun, 08 Jul 2018 13:32:48 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/08/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</guid>
      <description>&lt;p&gt;“Invisible” proxy types can cause &lt;code&gt;auto&lt;/code&gt; to deduce the undesired type for an initializing expression, so we can adopt explicitly typed initializer idiom to force &lt;code&gt;auto&lt;/code&gt; to deduce what we want.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations</title>
      <link>https://sy123.ml/2018/07/07/prefer-auto-to-explicit-type-declarations/</link>
      <pubDate>Sat, 07 Jul 2018 13:33:06 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/07/prefer-auto-to-explicit-type-declarations/</guid>
      <description>&lt;p&gt;Despite some pitfalls described in EMCpp item 2 and 6, &lt;code&gt;auto&lt;/code&gt; variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-4 Know How to View Deduced Types</title>
      <link>https://sy123.ml/2018/07/06/know-how-to-view-deduced-types/</link>
      <pubDate>Fri, 06 Jul 2018 10:08:00 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/06/know-how-to-view-deduced-types/</guid>
      <description>&lt;p&gt;Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-3 Understand Decltype</title>
      <link>https://sy123.ml/2018/07/05/understand-decltype/</link>
      <pubDate>Thu, 05 Jul 2018 18:59:39 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/05/understand-decltype/</guid>
      <description>&lt;p&gt;&lt;code&gt;decltype&lt;/code&gt; almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, &lt;code&gt;decltype&lt;/code&gt; always reports a type of T&amp;amp;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-2 Understand Auto Type Deduction</title>
      <link>https://sy123.ml/2018/07/03/understand-auto-type-deduction/</link>
      <pubDate>Tue, 03 Jul 2018 10:07:13 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/03/understand-auto-type-deduction/</guid>
      <description>&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, &lt;code&gt;auto&lt;/code&gt; implies template type deduction instead of &lt;code&gt;auto&lt;/code&gt; type deduction.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-1 Understand Template Type Deduction</title>
      <link>https://sy123.ml/2018/07/02/understand-template-type-deduction/</link>
      <pubDate>Mon, 02 Jul 2018 22:44:34 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/02/understand-template-type-deduction/</guid>
      <description>&lt;p&gt;There are three sets of rules for type deduction in modern C++: one for function templates, one for &lt;code&gt;auto&lt;/code&gt;, and one for &lt;code&gt;decltype&lt;/code&gt;. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Brief Review of Dynamo</title>
      <link>https://sy123.ml/2018/07/01/a-brif-review-of-dynamo/</link>
      <pubDate>Sun, 01 Jul 2018 23:03:34 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/07/01/a-brif-review-of-dynamo/</guid>
      <description>&lt;p&gt;As a highly available and scalable distributed data store, the design principles of Dynamo features high availability for writes (via reconciliation during reads), incremental scalability (consistent hashing), symmetry, decentralization, and heterogeneity (via virtual nodes).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-34 Understand How to Combine C&#43;&#43; and C in the Same Program</title>
      <link>https://sy123.ml/2018/05/23/understand-how-to-combine-c-and-c-in-the-same-program/</link>
      <pubDate>Wed, 23 May 2018 18:38:10 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/05/23/understand-how-to-combine-c-and-c-in-the-same-program/</guid>
      <description>&lt;p&gt;There are five points worth noting if we want to mix C++ and C in the same program.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-33 Make Non-Leaf Classes Abstract</title>
      <link>https://sy123.ml/2018/05/21/make-non-leaf-classes-abstract/</link>
      <pubDate>Mon, 21 May 2018 18:27:39 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/05/21/make-non-leaf-classes-abstract/</guid>
      <description>&lt;p&gt;The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-32 Program in the Future Tense</title>
      <link>https://sy123.ml/2018/05/17/program-in-the-future-tense/</link>
      <pubDate>Thu, 17 May 2018 19:26:17 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/05/17/program-in-the-future-tense/</guid>
      <description>&lt;p&gt;Things change. Future tense thinking increases the reusability of the code we write, enhances its maintainability, makes it more robust, and facilitates gracefully in an environment where change is a certainty.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-31 Making Functions Virtual With Respect to More Than One Object</title>
      <link>https://sy123.ml/2018/05/11/making-functions-virtual-with-respect-to-more-than-one-object/</link>
      <pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/05/11/making-functions-virtual-with-respect-to-more-than-one-object/</guid>
      <description>&lt;p&gt;A virtual function call is termed a &amp;ldquo;message dispatch.&amp;rdquo; A call that acts virtual on multiple parameters is called &lt;em&gt;multiple dispatch&lt;/em&gt;, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-30 Proxy Classes</title>
      <link>https://sy123.ml/2018/05/09/proxy-classes/</link>
      <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/05/09/proxy-classes/</guid>
      <description>&lt;p&gt;Objects that stand for other objects are often called &lt;em&gt;proxy objects&lt;/em&gt; (or &lt;em&gt;surrogates&lt;/em&gt;), and the classes that give rise to proxy objects are often called &lt;em&gt;proxy classes&lt;/em&gt;, which is useful for implementing multidimensional arrays, differentiating lvalue/rvalue, and suppressing implicit conversions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-29 Reference Counting</title>
      <link>https://sy123.ml/2018/05/07/reference-counting/</link>
      <pubDate>Mon, 07 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/05/07/reference-counting/</guid>
      <description>&lt;p&gt;Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-28 Smart Pointers</title>
      <link>https://sy123.ml/2018/05/05/smart-pointers/</link>
      <pubDate>Sat, 05 May 2018 16:38:03 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/05/05/smart-pointers/</guid>
      <description>&lt;p&gt;&lt;em&gt;Smart pointers&lt;/em&gt; are designed to look, act, and feel like built-in pointers, but to offer greater functionality.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects</title>
      <link>https://sy123.ml/2018/05/01/requiring-or-prohibiting-heap-based-objects/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/05/01/requiring-or-prohibiting-heap-based-objects/</guid>
      <description>&lt;p&gt;Techniques for requiring or prohibiting heap-based objects&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-26 Limiting the Number of Objects of a Class</title>
      <link>https://sy123.ml/2018/04/24/limiting-the-number-of-objects-of-a-class/</link>
      <pubDate>Tue, 24 Apr 2018 15:03:26 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/24/limiting-the-number-of-objects-of-a-class/</guid>
      <description>&lt;p&gt;Combining object-counting technique with the pseudo-constructors, we can limit the number of objects of a class.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-25 Virtualizing Constructors and Non-Member Functions</title>
      <link>https://sy123.ml/2018/04/23/virtualizing-constructors-and-non-member-functions/</link>
      <pubDate>Mon, 23 Apr 2018 13:30:56 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/23/virtualizing-constructors-and-non-member-functions/</guid>
      <description>&lt;p&gt;Depending on the different input or dynamic types of function parameters, &amp;ldquo;virtualization&amp;rdquo; is a useful technique to construct new objects of different types accordingly, or to conceive of non-member functions whose behavior changes accordingly.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-24 Understand the Costs of Virtual Functions, Multiple Inheritance, Virtual Base Classes, and RTTI</title>
      <link>https://sy123.ml/2018/04/20/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</link>
      <pubDate>Fri, 20 Apr 2018 15:32:45 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/20/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</guid>
      <description>&lt;p&gt;It&#39;s important to have a basic understanding of the cost of some C++ features that can have a noticeable impact on the size of objects and the speed at which member functions execute.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-23 Consider Alternative Libraries</title>
      <link>https://sy123.ml/2018/04/19/consider-alternative-libraries/</link>
      <pubDate>Thu, 19 Apr 2018 13:32:15 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/19/consider-alternative-libraries/</guid>
      <description>&lt;p&gt;Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-22 Consider Using op= Instead of Stand Alone op</title>
      <link>https://sy123.ml/2018/04/18/consider-using-op-instead-of-stand-alone-op/</link>
      <pubDate>Wed, 18 Apr 2018 14:09:10 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/18/consider-using-op-instead-of-stand-alone-op/</guid>
      <description>&lt;p&gt;Assignment versions of operators (such as &lt;code&gt;operator+=&lt;/code&gt;) tend to be more efficient than stand-alone versions of those operators (e.g., &lt;code&gt;operator+&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-21 Overload to Avoid Implicit Type Conventions</title>
      <link>https://sy123.ml/2018/04/17/overload-to-avoid-implicit-type-conventions/</link>
      <pubDate>Tue, 17 Apr 2018 15:42:12 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/17/overload-to-avoid-implicit-type-conventions/</guid>
      <description>&lt;p&gt;Overloading to avoid temporaries.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-20 Facilitate the Return Value Optimization</title>
      <link>https://sy123.ml/2018/04/16/facilitate-the-return-value-optimization/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/04/16/facilitate-the-return-value-optimization/</guid>
      <description>&lt;p&gt;Take use of the &lt;em&gt;return value optimization&lt;/em&gt; in compilers.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-19 Understand the Origin of Temporary Objects</title>
      <link>https://sy123.ml/2018/04/13/understand-the-origin-of-temporary-objects/</link>
      <pubDate>Fri, 13 Apr 2018 17:06:28 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/13/understand-the-origin-of-temporary-objects/</guid>
      <description>&lt;p&gt;Unnamed non-heap objects are invisible temporary objects in C++.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-18 Amortize the Cost of Expected Computations</title>
      <link>https://sy123.ml/2018/04/12/amortize-the-cost-of-expected-computations/</link>
      <pubDate>Thu, 12 Apr 2018 15:31:55 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/12/amortize-the-cost-of-expected-computations/</guid>
      <description>&lt;p&gt;The old Computer Science story: trade space for time&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-17 Consider Using Lazy Evaluation</title>
      <link>https://sy123.ml/2018/04/11/consider-using-lazy-evaluation/</link>
      <pubDate>Wed, 11 Apr 2018 14:02:18 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/11/consider-using-lazy-evaluation/</guid>
      <description>&lt;p&gt;The best computations are those we never perform at all.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-16 Remember 80-20 Rule</title>
      <link>https://sy123.ml/2018/04/10/remember-80-20-rule/</link>
      <pubDate>Tue, 10 Apr 2018 13:37:45 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/10/remember-80-20-rule/</guid>
      <description>&lt;p&gt;The 80-20 rule states that 80 percent of a program&#39;s resources are used by about 20 percent of the code.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-15 Understand the Costs of Exception Handling</title>
      <link>https://sy123.ml/2018/04/09/understand-the-costs-of-exception-handling/</link>
      <pubDate>Mon, 09 Apr 2018 18:10:06 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/09/understand-the-costs-of-exception-handling/</guid>
      <description>&lt;p&gt;Exception handling has costs, and we pay at least some of them even if we never use the keywords &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;catch&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-14 Use Exception Specifications Judiciously</title>
      <link>https://sy123.ml/2018/04/08/use-exception-specifications-judiciously/</link>
      <pubDate>Sun, 08 Apr 2018 23:51:00 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/08/use-exception-specifications-judiciously/</guid>
      <description>&lt;p&gt;Exception specifications provide a documentation aid and an enforcement mechanism for constraints on exception usage, but they are only partly checked by compilers and they are easy to violate inadvertently.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-13 Catch Exceptions by Reference</title>
      <link>https://sy123.ml/2018/04/05/catch-exceptions-by-reference/</link>
      <pubDate>Thu, 05 Apr 2018 18:57:13 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/05/catch-exceptions-by-reference/</guid>
      <description>&lt;p&gt;If catching by reference, we sidestep the questions about object deletion, avoid slicing exception objects, retain the ability to catch standard exceptions, and limit the number of times exception objects being copied.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-12 Understand How Throwing an Exception Differs From Passing a Parameter or Calling a Virtual Function</title>
      <link>https://sy123.ml/2018/04/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</link>
      <pubDate>Wed, 04 Apr 2018 11:28:07 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</guid>
      <description>&lt;p&gt;There are three primary ways in which passing an object to a function or using that object to invoke a virtual function differs from throwing the object as an exception.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-11 Prevent Exceptions From Leaving Destructors</title>
      <link>https://sy123.ml/2018/04/03/prevent-exceptions-from-leaving-destructors/</link>
      <pubDate>Tue, 03 Apr 2018 10:54:39 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/03/prevent-exceptions-from-leaving-destructors/</guid>
      <description>&lt;p&gt;Keep exceptions from propagating out of destructors to prevent C++ calling &lt;code&gt;terminate&lt;/code&gt; during the statck-unwinding part of exception propagation and ensure that every neccessary cleanup is accomplished.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-10 Prevent Resource Leaks in Constructors</title>
      <link>https://sy123.ml/2018/04/02/prevent-resource-leaks-in-constructors/</link>
      <pubDate>Mon, 02 Apr 2018 15:56:25 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/04/02/prevent-resource-leaks-in-constructors/</guid>
      <description>&lt;p&gt;Replace pointer class members with their corresponding smart pointer objects to fortify the constructors against resource leaks in the presence of exceptions, to eliminate the need to manually deallocate resources in destructors, and to allow &lt;code&gt;const&lt;/code&gt; member pointers to be handled in the smae graceful fashion as non-&lt;code&gt;const&lt;/code&gt; pointers.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-9 Use Destructors to Prevent Resource Leaks</title>
      <link>https://sy123.ml/2018/04/01/use-destructors-to-prevent-resource-leaks/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/04/01/use-destructors-to-prevent-resource-leaks/</guid>
      <description>&lt;p&gt;To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-8 Understand the Different Meanings of New and Delete</title>
      <link>https://sy123.ml/2018/03/30/understand-the-different-meanings-of-new-and-delete/</link>
      <pubDate>Fri, 30 Mar 2018 17:09:04 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/30/understand-the-different-meanings-of-new-and-delete/</guid>
      <description>&lt;p&gt;The behaviors of &lt;code&gt;new&lt;/code&gt; operator and &lt;code&gt;operator new&lt;/code&gt; is different.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39;</title>
      <link>https://sy123.ml/2018/03/29/never-overload-and-or-comma-operator/</link>
      <pubDate>Thu, 29 Mar 2018 11:18:24 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/29/never-overload-and-or-comma-operator/</guid>
      <description>&lt;p&gt;If we don&#39;t have a good reason for overloading an operator, don&#39;t overload it. In the case of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;, it&#39;s difficult to have a good reason: we can&#39;t make them behave the way they&#39;re supposed to.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-6 Distinguish Between Prefix and Postfix Forms of Increment and Decrement Operators</title>
      <link>https://sy123.ml/2018/03/28/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</link>
      <pubDate>Wed, 28 Mar 2018 13:03:10 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/28/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</guid>
      <description>&lt;p&gt;The prefix and postfix forms of increment and decrement operators return &lt;em&gt;different types&lt;/em&gt;: prefix forms return a reference, while postfix forms return a &lt;em&gt;const&lt;/em&gt; object. For efficiency, prefer prefix forms unless the behavior of postfix ones is necessary. To guarantee consistency, implement postfix operators in terms of the prefix operators.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-5 Be Wary of User Defined Conversion Functions</title>
      <link>https://sy123.ml/2018/03/27/be-wary-of-user-defined-conversion-functions/</link>
      <pubDate>Tue, 27 Mar 2018 18:53:56 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/27/be-wary-of-user-defined-conversion-functions/</guid>
      <description>&lt;p&gt;Implicit type conversions usually lead to more harm than good, so don&#39;t provide conversion functions unless we&#39;re sure we want them.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-4 Avoid Gratuitous Default Constructors</title>
      <link>https://sy123.ml/2018/03/26/avoid-gratuitous-default-constructors/</link>
      <pubDate>Mon, 26 Mar 2018 11:21:08 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/26/avoid-gratuitous-default-constructors/</guid>
      <description>&lt;p&gt;Including meaningless default constructors affects the efficiency of classes, so avoiding them in classes guarantees fully-initialized objects, with the cost of some limits on how such classes can be used.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-3 Never Treat Arrays Polymorphically</title>
      <link>https://sy123.ml/2018/03/23/never-treat-arrays-polymorphically/</link>
      <pubDate>Fri, 23 Mar 2018 18:59:16 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/23/never-treat-arrays-polymorphically/</guid>
      <description>&lt;p&gt;Array operations almost always involve pointer arithmetic, so arrays and polymorphism don&#39;t mix.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-1 Distinguish Between Pointers and References</title>
      <link>https://sy123.ml/2018/03/22/distinguish-between-pointers-and-references/</link>
      <pubDate>Thu, 22 Mar 2018 16:47:15 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/22/distinguish-between-pointers-and-references/</guid>
      <description>&lt;p&gt;More effective C++: Use references when we already have something to refer to and never want to refer to anything else, or when implementing operators whose syntactic requires us to do so.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-52 Write placement delete if you write placement new</title>
      <link>https://sy123.ml/2018/03/21/write-placement-delete-if-you-write-placement-new/</link>
      <pubDate>Wed, 21 Mar 2018 15:48:12 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/21/write-placement-delete-if-you-write-placement-new/</guid>
      <description>&lt;p&gt;When we write a placement version of &lt;code&gt;operator new&lt;/code&gt;, be sure to write the corresponding placement version of &lt;code&gt;operator delete&lt;/code&gt; to avoid subtle, intermittent memory leaks. When we do so, pay attention not to unintentionally hide the normal versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-51 Adhere to convention when writing new and delete</title>
      <link>https://sy123.ml/2018/03/20/adhere-to-convention-when-writing-new-and-delete/</link>
      <pubDate>Tue, 20 Mar 2018 14:32:24 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/20/adhere-to-convention-when-writing-new-and-delete/</guid>
      <description>&lt;p&gt;&lt;code&gt;operator new&lt;/code&gt; should contain an infinite loop trying to allocate memory, should call the new-handler if it can&#39;t satisfy a memory request, and should handle requests for zero bytes; class-specific versions should handle requests for larger blocks than expected. &lt;code&gt;operator delete&lt;/code&gt; should do nothing if passed a pointer that is null; class specific versions should handle blocks that are larger than expected.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-50 Understand when it makes sense to replace new and delete</title>
      <link>https://sy123.ml/2018/03/19/understand-when-it-makes-sense-to-replace-new-and-delete/</link>
      <pubDate>Mon, 19 Mar 2018 10:54:04 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/19/understand-when-it-makes-sense-to-replace-new-and-delete/</guid>
      <description>&lt;p&gt;There are many valid reasons for writing custom versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, including improving performance, debugging heap usage errors, and collecting heap usage information.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-49 Understand the behavior of the new handler</title>
      <link>https://sy123.ml/2018/03/16/understand-the-behavior-of-the-new-handler/</link>
      <pubDate>Fri, 16 Mar 2018 19:52:09 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/16/understand-the-behavior-of-the-new-handler/</guid>
      <description>&lt;p&gt;&lt;code&gt;set-new-handler&lt;/code&gt; allows you to specify a function to be called when memory allocation requests cannot be satisfied.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-48 Be aware of template metaprogramming</title>
      <link>https://sy123.ml/2018/03/15/be-aware-of-template-metaprogramming/</link>
      <pubDate>Thu, 15 Mar 2018 23:00:22 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/15/be-aware-of-template-metaprogramming/</guid>
      <description>&lt;p&gt;Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-47 Use traits classes for information about types</title>
      <link>https://sy123.ml/2018/03/14/use-traits-classes-for-information-about-types/</link>
      <pubDate>Wed, 14 Mar 2018 18:49:03 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/14/use-traits-classes-for-information-about-types/</guid>
      <description>&lt;p&gt;Implemented by templates and template specializations, traits classes make information about types available during compilation. Combining traints with overloading, it is possible to perform compile-time &lt;code&gt;if...else&lt;/code&gt; tests on types.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-46 Define non-member function inside templates when type conversions are desired</title>
      <link>https://sy123.ml/2018/03/13/define-non-member-function-inside-templates-when-type-conversions-are-desired/</link>
      <pubDate>Tue, 13 Mar 2018 12:23:40 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/13/define-non-member-function-inside-templates-when-type-conversions-are-desired/</guid>
      <description>&lt;p&gt;When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-45 Use member function templates to accept all compatible types</title>
      <link>https://sy123.ml/2018/03/12/use-member-function-templates-to-accept-all-compatible-types/</link>
      <pubDate>Mon, 12 Mar 2018 20:14:47 -0400</pubDate>
      
      <guid>https://sy123.ml/2018/03/12/use-member-function-templates-to-accept-all-compatible-types/</guid>
      <description>&lt;p&gt;In order to implicitly convert all compatible types for a template class, we neet not a constructor &lt;em&gt;function&lt;/em&gt; but a constructor &lt;em&gt;template&lt;/em&gt; - &lt;em&gt;member functoin templates&lt;/em&gt; that generate member functions of a class.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-44 Factor parameter-independent code out of templates</title>
      <link>https://sy123.ml/2018/03/10/factor-parameter-independent-code-out-of-templates/</link>
      <pubDate>Sat, 10 Mar 2018 20:24:42 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/10/factor-parameter-independent-code-out-of-templates/</guid>
      <description>&lt;p&gt;Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter (either non-type template parameters or type parameters) causes bloat: eliminate bloat due to non-type template parameters by replacing template parameters with function parameters or class data members; reduce bloat caused from type parameters by sharing implementations for instantiation types with identical binary representations.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-43 Know how to access names in templatized base classes</title>
      <link>https://sy123.ml/2018/03/09/know-how-to-access-names-in-templatized-base-classes/</link>
      <pubDate>Fri, 09 Mar 2018 21:48:26 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/09/know-how-to-access-names-in-templatized-base-classes/</guid>
      <description>&lt;p&gt;In derived class templates, refer to names in base class templates via a &lt;code&gt;this-&amp;gt;&lt;/code&gt; prefix, via &lt;code&gt;using&lt;/code&gt; declarations, or via an explicit base class qualification.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-42 Understand the two meanings of typename</title>
      <link>https://sy123.ml/2018/03/08/understand-the-two-meanings-of-typename/</link>
      <pubDate>Thu, 08 Mar 2018 19:19:28 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/08/understand-the-two-meanings-of-typename/</guid>
      <description>&lt;p&gt;When declaring template parameters, both &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;typename&lt;/code&gt; are interchangeable. When identifying nested dependent type names, use &lt;code&gt;typename&lt;/code&gt;, except in base class lists or as a base class identifier in a member initialization list.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-41 Understand inplicit interfaces and compile time polymorphism</title>
      <link>https://sy123.ml/2018/03/07/understand-inplicit-interfaces-and-compile-time-polymorphism/</link>
      <pubDate>Wed, 07 Mar 2018 14:21:33 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/07/understand-inplicit-interfaces-and-compile-time-polymorphism/</guid>
      <description>&lt;p&gt;Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-40 Use multiple inheritance judiciously</title>
      <link>https://sy123.ml/2018/03/06/use-multiple-inheritance-judiciously/</link>
      <pubDate>Tue, 06 Mar 2018 17:35:59 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/06/use-multiple-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Being more complex than single inheritance, Multiple inheritance (MI) can lead to ambiguity issues and to the need for virtual inheritance, the latter of which imposes costs in size, speed, and complexity of initialization and assignment, so it&#39;s more practical to make &amp;ldquo;empty&amp;rdquo; virtual base classes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-39 Use private inheritance judiciously</title>
      <link>https://sy123.ml/2018/03/05/use-private-inheritance-judiciously/</link>
      <pubDate>Mon, 05 Mar 2018 18:42:43 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/05/use-private-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Private inheritance means is-implemented-in-terms-of. It is usually inferior to composition, but it makes sense when a derived class needs access to protected base members or needs to redefine inherited virtual functions. For library developers who strive to minimize object sizes, it also offers the ability of empty base optimization.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-38 Model &#39;has-a&#39; or &#39;is-implemented-in-terms-of&#39; through composition</title>
      <link>https://sy123.ml/2018/03/04/model-has-a-or-is-implemented-in-terms-of-through-composition/</link>
      <pubDate>Sun, 04 Mar 2018 15:49:31 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/04/model-has-a-or-is-implemented-in-terms-of-through-composition/</guid>
      <description>&lt;p&gt;In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-37 Never redefine a function&#39;s inherited default parameter value</title>
      <link>https://sy123.ml/2018/03/02/never-redefine-a-functions-inherited-default-parameter-value/</link>
      <pubDate>Fri, 02 Mar 2018 21:15:36 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/02/never-redefine-a-functions-inherited-default-parameter-value/</guid>
      <description>&lt;p&gt;Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-36 Never redefine an inherited non-virtaul function</title>
      <link>https://sy123.ml/2018/03/01/never-redefine-an-inherited-non-virtaul-function/</link>
      <pubDate>Thu, 01 Mar 2018 20:22:17 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/03/01/never-redefine-an-inherited-non-virtaul-function/</guid>
      <description>&lt;p&gt;A generalized basic rule from item 7.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-35 Consider Alternatives to Virtual Functions</title>
      <link>https://sy123.ml/2018/02/28/consider-alternatives-to-virtual-functions/</link>
      <pubDate>Wed, 28 Feb 2018 20:27:02 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/28/consider-alternatives-to-virtual-functions/</guid>
      <description>&lt;p&gt;Alternatives to virtual functions include the NVI idiom (as an example of the Template Method design pattern) and various forms of the Strategy design pattern.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-34 Differentiate between inheritance of interface and inheritance of implementation</title>
      <link>https://sy123.ml/2018/02/27/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</link>
      <pubDate>Tue, 27 Feb 2018 20:53:53 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/27/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</guid>
      <description>&lt;p&gt;Inheritance of interface is different from inheritance of implementatino.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-33 Avoid hiding inherited names</title>
      <link>https://sy123.ml/2018/02/26/avoid-hiding-inherited-names/</link>
      <pubDate>Mon, 26 Feb 2018 20:18:55 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/26/avoid-hiding-inherited-names/</guid>
      <description>&lt;p&gt;Names in derived classes hide names in base classes, which is not desirable in public inheritance. To fix it, employ &lt;code&gt;using&lt;/code&gt; declarations or forwarding functions to make hidden names visible again.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-32 Make sure public inheritance models &#34;Is-A&#34;</title>
      <link>https://sy123.ml/2018/02/23/make-sure-public-inheritance-models-is-a/</link>
      <pubDate>Fri, 23 Feb 2018 12:59:53 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/23/make-sure-public-inheritance-models-is-a/</guid>
      <description>&lt;p&gt;Everything that applies to base classes must also apply to derived classes in public inheritance, for every derived class object &lt;em&gt;is&lt;/em&gt; a base class object.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-31 Minimize compilation dependencies between files</title>
      <link>https://sy123.ml/2018/02/22/minimize-compilation-dependencies-between-files/</link>
      <pubDate>Thu, 22 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/02/22/minimize-compilation-dependencies-between-files/</guid>
      <description>&lt;p&gt;To minimize compilation dependencies, depend on declarations instead of definitions via techniques such as Handle classes and Interface classes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-30 Understand ins and outs of inlining</title>
      <link>https://sy123.ml/2018/02/21/ins-and-outs-of-inlining/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/02/21/ins-and-outs-of-inlining/</guid>
      <description>&lt;p&gt;Limit most inlining to small, frequently called functions to facilitate debugging and binary upgradability, minimize potential code bloat, and maximize the chances of greater program speed.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-29 Strive for exception-safe code</title>
      <link>https://sy123.ml/2018/02/20/strive-for-exception-safe-code/</link>
      <pubDate>Tue, 20 Feb 2018 18:23:38 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/20/strive-for-exception-safe-code/</guid>
      <description>&lt;p&gt;Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer the basic, strong, and nothrow guarantees.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-28 Avoid returning handles to object internals</title>
      <link>https://sy123.ml/2018/02/16/avoid-return-handles-to-obejct-internals/</link>
      <pubDate>Fri, 16 Feb 2018 12:26:14 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/16/avoid-return-handles-to-obejct-internals/</guid>
      <description>&lt;p&gt;Avoid returning handles to object internals to increase encapsulation, help &lt;code&gt;const&lt;/code&gt; member functions act &lt;code&gt;const&lt;/code&gt;, and minimize the creation of dangling handles.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-27 Minimize_casting</title>
      <link>https://sy123.ml/2018/02/15/minimize-casting/</link>
      <pubDate>Thu, 15 Feb 2018 17:43:53 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/15/minimize-casting/</guid>
      <description>&lt;p&gt;Avoid casts and develop a cast-free alternative whenever practical, especially &lt;code&gt;dynamic_cast&lt;/code&gt; in performance-sensitive code.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-26 Postpone variable definitions as long as possible</title>
      <link>https://sy123.ml/2018/02/14/postpone-variable-definitions/</link>
      <pubDate>Wed, 14 Feb 2018 10:50:18 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/14/postpone-variable-definitions/</guid>
      <description>&lt;p&gt;Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-25 Consider support for a non-throwing swap</title>
      <link>https://sy123.ml/2018/02/13/support-for-a-non-throwing-swap/</link>
      <pubDate>Tue, 13 Feb 2018 19:11:15 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/13/support-for-a-non-throwing-swap/</guid>
      <description>&lt;p&gt;When &lt;code&gt;std::swap&lt;/code&gt; would be inefficient for your type,provide a non-throwing &lt;code&gt;swap&lt;/code&gt; member function, a non-member &lt;code&gt;swap&lt;/code&gt; calling the member, and possibly a specialized &lt;code&gt;std::swap&lt;/code&gt; for the case of classes (not templates).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-24 Declare non-member functions when type conversions should apply to all parameters</title>
      <link>https://sy123.ml/2018/02/12/when-to-declare-non-member-functions/</link>
      <pubDate>Mon, 12 Feb 2018 22:47:20 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/12/when-to-declare-non-member-functions/</guid>
      <description>&lt;p&gt;If we need type conversions on all parameters to a function including the one pointed to by the &lt;code&gt;this&lt;/code&gt; pointer, the function must be a non-member.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-23 Prefer non-member non-friend function to member function</title>
      <link>https://sy123.ml/2018/02/11/prefer-non-member-non-friend-function-to-member-function/</link>
      <pubDate>Sun, 11 Feb 2018 21:33:28 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/11/prefer-non-member-non-friend-function-to-member-function/</guid>
      <description>&lt;p&gt;Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-22 Declare data members private</title>
      <link>https://sy123.ml/2018/02/10/declare-data-members-private/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/02/10/declare-data-members-private/</guid>
      <description>&lt;p&gt;Declaring data members &lt;code&gt;private&lt;/code&gt; gives clients syntactically uniform access to data, affords fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-21 Don&#39;t return a reference when we have to return an object</title>
      <link>https://sy123.ml/2018/02/09/do-not-return-a-ref-when-must-return-an-object/</link>
      <pubDate>Fri, 09 Feb 2018 18:02:23 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/09/do-not-return-a-ref-when-must-return-an-object/</guid>
      <description>&lt;p&gt;Never return a pointer or reference to a local stack object, a refenrence to a heap-allocated object, or a pointer or reference to a local static object if there is a change that more than one such object will be needed (item 4 provides a &amp;ldquo;counter&amp;rdquo; example that is reasonable in single-threaded environments).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-20 Perfer pass-by-reference-to-const to pass-by-value</title>
      <link>https://sy123.ml/2018/02/08/perfer-pass-by-reference-to-const/</link>
      <pubDate>Thu, 08 Feb 2018 16:26:33 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/08/perfer-pass-by-reference-to-const/</guid>
      <description>&lt;p&gt;Pass by reference-to-&lt;code&gt;const&lt;/code&gt; is typically more efficient than pass by value and avoids the slicing problem.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-19 Treat class design as type design</title>
      <link>https://sy123.ml/2018/02/07/class-design-is-type-design/</link>
      <pubDate>Wed, 07 Feb 2018 13:47:07 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/07/class-design-is-type-design/</guid>
      <description>&lt;p&gt;Before definining a new type, be sure to consider all the issues discussed in this item.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-18 Make interfaces easy to use correctly and hard to use incorrectly</title>
      <link>https://sy123.ml/2018/02/06/make-interfaces-easy-to-use-correctly/</link>
      <pubDate>Tue, 06 Feb 2018 19:05:53 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/06/make-interfaces-easy-to-use-correctly/</guid>
      <description>&lt;p&gt;Good interfaces are easy to use correctly and hard to use incorrectly.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2018进度表</title>
      <link>https://sy123.ml/2018/02/06/2018-roadmap/</link>
      <pubDate>Tue, 06 Feb 2018 11:44:42 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/06/2018-roadmap/</guid>
      <description>&lt;p&gt;马上春节了，来列一下新年计划吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-17 Store newed objects in smart pointers in standalone statements</title>
      <link>https://sy123.ml/2018/02/05/store-newed-objects-in-smart-pointers-in-standalone-statements/</link>
      <pubDate>Mon, 05 Feb 2018 18:04:38 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/05/store-newed-objects-in-smart-pointers-in-standalone-statements/</guid>
      <description>&lt;p&gt;Failure to do this can lead to subtle resource leaks when exceptions are thrown.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-16 Use the same form in corresponding uses of new and delete</title>
      <link>https://sy123.ml/2018/02/04/use-the-same-form-in-matching-new-and-delete/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/02/04/use-the-same-form-in-matching-new-and-delete/</guid>
      <description>&lt;p&gt;If you use [] in a &lt;code&gt;new&lt;/code&gt; expression, use [] in the corresponding &lt;code&gt;delete&lt;/code&gt; expression; If not, no [] in the matching &lt;code&gt;delete&lt;/code&gt; expression.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-15 Provide access to raw resource in resource-managing classes</title>
      <link>https://sy123.ml/2018/02/03/provide-access-to-raw-rsc/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/02/03/provide-access-to-raw-rsc/</guid>
      <description>&lt;p&gt;Each RAII class should offer a way to get at the resource it manages.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-14 Copy behavior in resource-managing classes</title>
      <link>https://sy123.ml/2018/02/02/copy-behavior-of-raii/</link>
      <pubDate>Fri, 02 Feb 2018 13:27:32 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/02/copy-behavior-of-raii/</guid>
      <description>&lt;p&gt;Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-13 Use objects to manage resources</title>
      <link>https://sy123.ml/2018/02/01/use-objects-to-manage-resources/</link>
      <pubDate>Thu, 01 Feb 2018 18:20:10 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/02/01/use-objects-to-manage-resources/</guid>
      <description>&lt;p&gt;Use RAII objects such as &lt;code&gt;tr1::shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; to prevent resource leaks.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-12 Copy all parts of an object</title>
      <link>https://sy123.ml/2018/01/31/copy-all-parts-of-an-object/</link>
      <pubDate>Wed, 31 Jan 2018 18:16:11 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/31/copy-all-parts-of-an-object/</guid>
      <description>&lt;p&gt;Be sure to copy all of an object&#39;s data members and all of its base class parts.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-11 Handle self assignment in operator=</title>
      <link>https://sy123.ml/2018/01/30/handle-self-assignment/</link>
      <pubDate>Tue, 30 Jan 2018 18:34:01 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/30/handle-self-assignment/</guid>
      <description>&lt;p&gt;Solve self assignment situation in operator= by comparing addresses of source and target objects, careful statement ordering, and copy-and-&lt;code&gt;swap&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-10 Have assignment operators return a reference to *this</title>
      <link>https://sy123.ml/2018/01/29/have-assignment-op-return-a-ref/</link>
      <pubDate>Mon, 29 Jan 2018 18:17:34 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/29/have-assignment-op-return-a-ref/</guid>
      <description>&lt;p&gt;As title suggests.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-9 不要在构造函数和析构函数中触发虚函数</title>
      <link>https://sy123.ml/2018/01/27/no-virtual-func-in-ctor-dtor/</link>
      <pubDate>Sat, 27 Jan 2018 21:03:05 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/27/no-virtual-func-in-ctor-dtor/</guid>
      <description>&lt;p&gt;不同于Java或者C#,在C++中构造函数和析构函数里的虚函数不会实现多态的效果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-8 Prevent exception from leaving destructor</title>
      <link>https://sy123.ml/2018/01/26/prevent-exception-from-leaving-dtor/</link>
      <pubDate>Fri, 26 Jan 2018 20:15:48 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/26/prevent-exception-from-leaving-dtor/</guid>
      <description>&lt;p&gt;It is discouraged practice to emit exceptions from destructors.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-7 Declare destructor virtual in polymorphic base classes</title>
      <link>https://sy123.ml/2018/01/25/virtual-dtor-in-polymorphic-base-class/</link>
      <pubDate>Thu, 25 Jan 2018 18:04:14 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/25/virtual-dtor-in-polymorphic-base-class/</guid>
      <description>&lt;p&gt;If a class has any virtual functions (for polymorphic purpose), it should have a virtual destructor.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-6 Disallow unwanted compiler-generated functions</title>
      <link>https://sy123.ml/2018/01/24/functions-silently-created/</link>
      <pubDate>Wed, 24 Jan 2018 16:18:59 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/24/functions-silently-created/</guid>
      <description>&lt;p&gt;Declare unwanted member functions &lt;em&gt;private&lt;/em&gt; without implementations to disallow functionality automatically provided by compilers.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-5 What functions C&#43;&#43; silently generates</title>
      <link>https://sy123.ml/2018/01/23/functions-silently-created/</link>
      <pubDate>Tue, 23 Jan 2018 18:42:07 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/23/functions-silently-created/</guid>
      <description>&lt;p&gt;Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-4 Initialize objects before they&#39;re used</title>
      <link>https://sy123.ml/2018/01/22/initialize-before-use/</link>
      <pubDate>Mon, 22 Jan 2018 18:47:54 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/22/initialize-before-use/</guid>
      <description>&lt;p&gt;Since C++ is fickle about initialization, some good coding style is suggested.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-3 Use const whenever possible</title>
      <link>https://sy123.ml/2018/01/19/use-const-whenever-possible/</link>
      <pubDate>Fri, 19 Jan 2018 14:31:40 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/19/use-const-whenever-possible/</guid>
      <description>&lt;p&gt;Useful tips on using &lt;code&gt;const&lt;/code&gt; in C++.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-0 Federation of languages</title>
      <link>https://sy123.ml/2018/01/18/cpp-is-multiparadigm/</link>
      <pubDate>Thu, 18 Jan 2018 20:01:47 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/18/cpp-is-multiparadigm/</guid>
      <description>&lt;p&gt;C++ is a multiparadigm programming langrage.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-2 Compare &lt;iostream&gt; to &lt;stdio.h&gt;</title>
      <link>https://sy123.ml/2018/01/17/tips-on-iostream/</link>
      <pubDate>Wed, 17 Jan 2018 19:14:29 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/17/tips-on-iostream/</guid>
      <description>&lt;p&gt;Some tips about &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Effective JavaScript Checklist</title>
      <link>https://sy123.ml/2018/01/16/start-of-effective-cpp-series/</link>
      <pubDate>Tue, 16 Jan 2018 18:42:21 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/16/start-of-effective-cpp-series/</guid>
      <description>&lt;p&gt;My notes on reviewing &lt;code&gt;JavaScript&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-1 Prefer consts, enums and inlines to #defines</title>
      <link>https://sy123.ml/2018/01/16/start-of-effective-cpp-series/</link>
      <pubDate>Tue, 16 Jan 2018 18:41:58 -0500</pubDate>
      
      <guid>https://sy123.ml/2018/01/16/start-of-effective-cpp-series/</guid>
      <description>&lt;p&gt;A new (hopefully) daily review on &lt;code&gt;C++&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Machine learning overview</title>
      <link>https://sy123.ml/2018/01/04/start-of-machine-learning-series/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2018/01/04/start-of-machine-learning-series/</guid>
      <description>&lt;p&gt;My first post in the new &lt;code&gt;machine learning&lt;/code&gt; series.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Hugo在GitHub Pages上搭建免费个人网站</title>
      <link>https://sy123.ml/2017/12/26/personal-site-with-hugo/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://sy123.ml/2017/12/26/personal-site-with-hugo/</guid>
      <description>&lt;p&gt;This article talks about how to use &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; to build a personal website hosted on &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;. It also introduces how to find a free custom domain name from &lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt; and migrated the DNS server to &lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt; in order to use HTTPs with chosen custom domain name on GitHub Pages.&lt;br&gt;
本文讲述了如何使用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;将个人网页托管在&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上。同时也介绍了如何在&lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt;上找到免费个人域名并利用&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt;的免费DNS服务在Github Pages上以HTTPs协议加载个人域名。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>